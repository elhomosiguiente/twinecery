(dp0
S'buildDestination'
p1
S''
p2
sS'saveDestination'
p3
V/Users/mrfb/Documents/git/twinecery/twinecery.tws
p4
sS'metadata'
p5
(dp6
sS'target'
p7
S'sugarcane'
p8
sS'storyPanel'
p9
(dp10
S'widgets'
p11
(lp12
(dp13
S'selected'
p14
I00
sS'pos'
p15
(lp16
F10.0
aF290.0
asS'passage'
p17
(itiddlywiki
Tiddler
p18
(dp20
S'text'
p21
V<<if !tale.grammar>>\u000a	<<if tracery>>\u000a		<<set tale.grammar = tracery.createGrammar(tale.story.data)>>\u000a		<<print console.log("grammar: ", tale.grammar)>>\u000a	<<else>>\u000a		<<print console.log("grammar instantiation failed")>>\u000a	<<endif>>\u000a<<endif>>
p22
sS'title'
p23
VtraceryInit
p24
sS'modified'
p25
ctime
struct_time
p26
((I2015
I5
I30
I12
I44
I59
I5
I150
I1
tp27
(dp28
tp29
Rp30
sS'tags'
p31
(lp32
sS'created'
p33
g26
((I2015
I5
I29
I11
I56
I58
I4
I149
I1
tp34
(dp35
tp36
Rp37
sbsa(dp38
g14
I00
sg15
(lp39
F150.0
aF290.0
asg17
(itiddlywiki
Tiddler
p40
(dp41
g21
Vwindow.tracery = {\u000a    utilities : {}\u000a};\u000a\u000a(function () {/**\u000a * @author Kate Compton\u000a */\u000a\u000afunction inQuotes(s) {\u000a    return '"' + s + '"';\u000a};\u000a\u000afunction parseAction(action) {\u000a    return action;\u000a};\u000a\u000a// tag format\u000a// a thing to expand, plus actions\u000a\u000afunction parseTag(tag) {\u000a    var errors = [];\u000a    var prefxns = [];\u000a    var postfxns = [];\u000a\u000a    var lvl = 0;\u000a    var start = 0;\u000a\u000a    var inPre = true;\u000a\u000a    var symbol,\u000a        mods;\u000a\u000a    function nonAction(end) {\u000a        if (start !== end) {\u000a            var section = tag.substring(start, end);\u000a            if (!inPre) {\u000a                errors.push("multiple possible expansion symbols in tag!" + tag);\u000a            } else {\u000a                inPre = false;\u000a                var split = section.split(".");\u000a                symbol = split[0];\u000a                mods = split.slice(1, split.length);\u000a            }\u000a\u000a        }\u000a        start = end;\u000a    };\u000a\u000a    for (var i = 0; i < tag.length; i++) {\u000a        var c = tag.charAt(i);\u000a\u000a        switch(c) {\u000a        case '[':\u000a            if (lvl === 0) {\u000a                nonAction(i);\u000a            }\u000a\u000a            lvl++;\u000a            break;\u000a        case ']':\u000a            lvl--;\u000a            if (lvl === 0) {\u000a                var section = tag.substring(start + 1, i);\u000a                if (inPre)\u000a                    prefxns.push(parseAction(section));\u000a                else\u000a                    postfxns.push(parseAction(section));\u000a                start = i + 1;\u000a            }\u000a            break;\u000a\u000a        default:\u000a            if (lvl === 0) {\u000a\u000a            }\u000a            break;\u000a\u000a        }\u000a    }\u000a    nonAction(i);\u000a\u000a    if (lvl > 0) {\u000a        var error = "Too many '[' in rule " + inQuotes(tag);\u000a        errors.push(error);\u000a\u000a    }\u000a\u000a    if (lvl < 0) {\u000a        var error = "Too many ']' in rule " + inQuotes(tag);\u000a        errors.push(error);\u000a\u000a    }\u000a\u000a    return {\u000a        preActions : prefxns,\u000a        postActions : postfxns,\u000a        symbol : symbol,\u000a        mods : mods,\u000a        raw : tag,\u000a        errors : errors,\u000a    };\u000a};\u000a\u000a// Split a rule into sections\u000afunction parseRule(rule) {\u000a    var sections = [];\u000a    var errors = [];\u000a    if (!( typeof rule == 'string' || rule instanceof String)) {\u000a        errors.push("Cannot parse non-string rule " + rule);\u000a        sections.errors = errors;\u000a        return sections;\u000a    }\u000a\u000a    if (rule.length === 0) {\u000a        return [];\u000a    }\u000a\u000a    var lvl = 0;\u000a    var start = 0;\u000a    var inTag = false;\u000a\u000a    function createSection(end) {\u000a        var section = rule.substring(start, end);\u000a        if (section.length > 0) {\u000a            if (inTag)\u000a                sections.push(parseTag(section));\u000a            else\u000a                sections.push(section);\u000a        }\u000a        inTag = !inTag;\u000a        start = end + 1;\u000a\u000a    }\u000a\u000a    for (var i = 0; i < rule.length; i++) {\u000a        var c = rule.charAt(i);\u000a\u000a        switch(c) {\u000a        case '[':\u000a            lvl++;\u000a            break;\u000a        case ']':\u000a            lvl--;\u000a            break;\u000a        case '#':\u000a            if (lvl === 0) {\u000a                createSection(i);\u000a            }\u000a            break;\u000a        default:\u000a            break;\u000a\u000a        }\u000a\u000a    }\u000a\u000a    if (lvl > 0) {\u000a        var error = "Too many '[' in rule " + inQuotes(rule);\u000a        errors.push(error);\u000a\u000a    }\u000a\u000a    if (lvl < 0) {\u000a        var error = "Too many ']' in rule " + inQuotes(rule);\u000a        errors.push(error);\u000a\u000a    }\u000a\u000a    if (inTag) {\u000a        var error = "Odd number of '#' in rule " + inQuotes(rule);\u000a        errors.push(error);\u000a    }\u000a\u000a    createSection(rule.length);\u000a    sections.errors = errors;\u000a    return sections;\u000a};\u000a\u000afunction testParse(rule, shouldFail) {\u000a    console.log("-------");\u000a    console.log("Test parse rule: " + inQuotes(rule) + " " + shouldFail);\u000a    var parsed = parseRule(rule);\u000a    if (parsed.errors && parsed.errors.length > 0) {\u000a        for (var i = 0; i < parsed.errors.length; i++) {\u000a            console.log(parsed.errors[i]);\u000a        }\u000a    }\u000a    \u000a\u000a}\u000a\u000afunction testParseTag(tag, shouldFail) {\u000a    console.log("-------");\u000a    console.log("Test parse tag: " + inQuotes(tag) + " " + shouldFail);\u000a    var parsed = parseTag(tag);\u000a    if (parsed.errors && parsed.errors.length > 0) {\u000a        for (var i = 0; i < parsed.errors.length; i++) {\u000a            console.log(parsed.errors[i]);\u000a        }\u000a    }\u000a}\u000a\u000atracery.testParse = testParse;\u000atracery.testParseTag = testParseTag;\u000atracery.parseRule = parseRule;\u000atracery.parseTag = parseTag;\u000a\u000a\u000afunction spacer(size) {\u000a    var s = "";\u000a    for (var i = 0; i < size * 3; i++) {\u000a        s += " ";\u000a    }\u000a    return s;\u000a}\u000a\u000a/* Simple JavaScript Inheritance\u000a * By John Resig http://ejohn.org/\u000a * MIT Licensed.\u000a */\u000a\u000afunction extend(destination, source) {\u000a    for (var k in source) {\u000a        if (source.hasOwnProperty(k)) {\u000a            destination[k] = source[k];\u000a        }\u000a    }\u000a    return destination;\u000a}\u000a\u000a// Inspired by base2 and Prototype\u000a(function() {\u000a    var initializing = false,\u000a        fnTest = /xyz/.test(function() { xyz;\u000a    }) ? /\u005cb_super\u005cb/ : /.*/;\u000a\u000a    // The base Class implementation (does nothing)\u000a    this.Class = function() {\u000a    };\u000a\u000a    // Create a new Class that inherits from this class\u000a    Class.extend = function(prop) {\u000a        var _super = this.prototype;\u000a\u000a        // Instantiate a base class (but only create the instance,\u000a        // don't run the init constructor)\u000a        initializing = true;\u000a        var prototype = new this();\u000a        initializing = false;\u000a\u000a        // Copy the properties over onto the new prototype\u000a        for (var name in prop) {\u000a            // Check if we're overwriting an existing function\u000a            prototype[name] = typeof prop[name] == "function" && typeof _super[name] == "function" && fnTest.test(prop[name]) ? (function(name, fn) {\u000a                return function() {\u000a                    var tmp = this._super;\u000a\u000a                    // Add a new ._super() method that is the same method\u000a                    // but on the super-class\u000a                    this._super = _super[name];\u000a\u000a                    // The method only need to be bound temporarily, so we\u000a                    // remove it when we're done executing\u000a                    var ret = fn.apply(this, arguments);\u000a                    this._super = tmp;\u000a\u000a                    return ret;\u000a                };\u000a            })(name, prop[name]) : prop[name];\u000a        }\u000a\u000a        // The dummy class constructor\u000a        function Class() {\u000a            // All construction is actually done in the init method\u000a            if (!initializing && this.init)\u000a                this.init.apply(this, arguments);\u000a        }\u000a\u000a        // Populate our constructed prototype object\u000a        Class.prototype = prototype;\u000a\u000a        // Enforce the constructor to be what we expect\u000a        Class.prototype.constructor = Class;\u000a\u000a        // And make this class extendable\u000a        Class.extend = arguments.callee;\u000a\u000a        return Class;\u000a    };\u000a})();\u000a\u000a/**\u000a * @author Kate\u000a */\u000a\u000avar Rule = function(raw) {\u000a    this.raw = raw;\u000a    this.sections = parseRule(raw);\u000a\u000a};\u000a\u000aRule.prototype.getParsed = function() {\u000a    if (!this.sections)\u000a        this.sections = parseRule(raw);\u000a\u000a    return this.sections;\u000a};\u000a\u000aRule.prototype.toString = function() {\u000a    return this.raw;\u000a};\u000a\u000aRule.prototype.toJSONString = function() {\u000a    return this.raw;\u000a};\u000a\u000a/**\u000a * @author Kate\u000a */\u000a\u000avar RuleWeighting = Object.freeze({\u000a    RED : 0,\u000a    GREEN : 1,\u000a    BLUE : 2\u000a});\u000a\u000avar RuleSet = function(rules) {\u000a    // is the rules obj an array? A RuleSet, or a string?\u000a    if (rules.constructor === Array) {\u000a        // make a copy\u000a        rules = rules.slice(0, rules.length);\u000a    } else if (rules.prototype === RuleSet) {\u000a        // clone\u000a    } else if ( typeof rules == 'string' || rules instanceof String) {\u000a        var args = Array.prototype.slice.call(arguments);\u000a        rules = args;\u000a    } else {\u000a        console.log(rules);\u000a        throw ("creating ruleset with unknown object type!");\u000a    }\u000a\u000a    // create rules and their use counts\u000a\u000a    this.rules = rules;\u000a    this.parseAll();\u000a\u000a    this.uses = [];\u000a    this.startUses = [];\u000a    this.totalUses = 0;\u000a    for (var i = 0; i < this.rules.length; i++) {\u000a        this.uses[i] = 0;\u000a        this.startUses[i] = this.uses[i];\u000a        this.totalUses += this.uses[i];\u000a    }\u000a\u000a};\u000a\u000a//========================================================\u000a// Iterating over rules\u000a\u000aRuleSet.prototype.parseAll = function(fxn) {\u000a    for (var i = 0; i < this.rules.length; i++) {\u000a        if (this.rules[i].prototype !== Rule)\u000a            this.rules[i] = new Rule(this.rules[i]);\u000a    }\u000a\u000a};\u000a\u000a//========================================================\u000a// Iterating over rules\u000a\u000aRuleSet.prototype.mapRules = function(fxn) {\u000a    return this.rules.map(function(rule, index) {\u000a        return fxn(rule, index);\u000a    });\u000a};\u000a\u000aRuleSet.prototype.applyToRules = function(fxn) {\u000a    for (var i = 0; i < this.rules.length; i++) {\u000a        fxn(this.rules[i], i);\u000a    }\u000a};\u000a//========================================================\u000aRuleSet.prototype.get = function() {\u000a    var index = this.getIndex();\u000a\u000a    return this.rules[index];\u000a};\u000a\u000aRuleSet.prototype.getRandomIndex = function() {\u000a    return Math.floor(this.uses.length * Math.random());\u000a};\u000a\u000aRuleSet.prototype.getIndex = function() {\u000a    // Weighted distribution\u000a    // Imagine a bar of length 1, how to divide the length\u000a    // s.t. a random dist will result in the dist we want?\u000a\u000a    var index = this.getRandomIndex();\u000a    // What if the uses determine the chance of rerolling?\u000a\u000a    var median = this.totalUses / this.uses.length;\u000a\u000a    var count = 0;\u000a    while (this.uses[index] > median && count < 20) {\u000a        index = this.getRandomIndex();\u000a        count++;\u000a    }\u000a\u000a    // reroll more likely if index is too much higher\u000a\u000a    return index;\u000a};\u000a\u000aRuleSet.prototype.decayUses = function(pct) {\u000a    this.totalUses = 0;\u000a    for (var i = 0; i < this.uses; i++) {\u000a\u000a        this.uses[index] *= 1 - pct;\u000a        this.totalUses += this.uses[index];\u000a    }\u000a};\u000a\u000aRuleSet.prototype.testRandom = function() {\u000a    console.log("Test random");\u000a    var counts = [];\u000a    for (var i = 0; i < this.uses.length; i++) {\u000a        counts[i] = 0;\u000a    }\u000a\u000a    var testCount = 10 * this.uses.length;\u000a    for (var i = 0; i < testCount; i++) {\u000a\u000a        var index = this.getIndex();\u000a        this.uses[index] += 1;\u000a\u000a        counts[index]++;\u000a        this.decayUses(.1);\u000a    }\u000a\u000a    for (var i = 0; i < this.uses.length; i++) {\u000a        console.log(i + ":\u005ct" + counts[i] + " \u005ct" + this.uses[i]);\u000a    }\u000a};\u000a\u000aRuleSet.prototype.getSaveRules = function() {\u000a    var jsonRules = this.rules.map(function(rule) {\u000a        return rule.toJSONString();\u000a    });\u000a\u000a    return jsonRules;\u000a};\u000a\u000a/**\u000a * @author Kate Compton\u000a */\u000a\u000avar Action = function(node, raw) {\u000a\u000a    this.node = node;\u000a    this.grammar = node.grammar;\u000a    this.raw = raw;\u000a\u000a};\u000a\u000aAction.prototype.activate = function() {\u000a\u000a    var node = this.node;\u000a    node.actions.push(this);\u000a\u000a    // replace any hashtags\u000a    this.amended = this.grammar.flatten(this.raw);\u000a\u000a    var parsed = parseTag(this.amended);\u000a    var subActionRaw = parsed.preActions;\u000a    if (subActionRaw && subActionRaw.length > 0) {\u000a        this.subactions = subActionRaw.map(function(action) {\u000a            return new Action(node, action);\u000a        });\u000a\u000a    }\u000a\u000a    if (parsed.symbol) {\u000a        var split = parsed.symbol.split(":");\u000a\u000a        if (split.length === 2) {\u000a            this.push = {\u000a                symbol : split[0],\u000a\u000a                // split into multiple rules\u000a                rules : split[1].split(","),\u000a            };\u000a            // push\u000a            node.grammar.pushRules(this.push.symbol, this.push.rules);\u000a\u000a        } else\u000a            throw ("Unknown action: " + parsed.symbol);\u000a    }\u000a\u000a    if (this.subactions) {\u000a        for (var i = 0; i < this.subactions.length; i++) {\u000a            this.subactions[i].activate();\u000a        }\u000a    }\u000a\u000a};\u000a\u000aAction.prototype.deactivate = function() {\u000a    if (this.subactions) {\u000a        for (var i = 0; i < this.subactions.length; i++) {\u000a            this.subactions[i].deactivate();\u000a        }\u000a    }\u000a\u000a    if (this.push) {\u000a        this.node.grammar.popRules(this.push.symbol, this.push.rules);\u000a    }\u000a};\u000a\u000a/**\u000a * @author Kate Compton\u000a */\u000a\u000avar isConsonant = function(c) {\u000a    c = c.toLowerCase();\u000a    switch(c) {\u000a    case 'a':\u000a        return false;\u000a    case 'e':\u000a        return false;\u000a    case 'i':\u000a        return false;\u000a    case 'o':\u000a        return false;\u000a    case 'u':\u000a        return false;\u000a\u000a    }\u000a    return true;\u000a};\u000a\u000afunction endsWithConY(s) {\u000a    if (s.charAt(s.length - 1) === 'y') {\u000a        return isConsonant(s.charAt(s.length - 2));\u000a    }\u000a    return false;\u000a};\u000a\u000avar universalModifiers = {\u000a    capitalizeAll : function(s) {\u000a        return s.replace(/(?:^|\u005cs)\u005cS/g, function(a) {\u000a            return a.toUpperCase();\u000a        });\u000a\u000a    },\u000a\u000a    capitalize : function(s) {\u000a        return s.charAt(0).toUpperCase() + s.slice(1);\u000a\u000a    },\u000a\u000a    inQuotes : function(s) {\u000a        return '"' + s + '"';\u000a    },\u000a\u000a    comma : function(s) {\u000a        var last = s.charAt(s.length - 1);\u000a        if (last === ",")\u000a            return s;\u000a        if (last === ".")\u000a            return s;\u000a        if (last === "?")\u000a            return s;\u000a        if (last === "!")\u000a            return s;\u000a        return s + ",";\u000a    },\u000a\u000a    beeSpeak : function(s) {\u000a        //            s = s.replace("s", "zzz");\u000a\u000a        s = s.replace(/s/, 'zzz');\u000a        return s;\u000a    },\u000a\u000a    a : function(s) {\u000a        if (!isConsonant(s.charAt()))\u000a            return "an " + s;\u000a        return "a " + s;\u000a\u000a    },\u000a\u000a    s : function(s) {\u000a\u000a        var last = s.charAt(s.length - 1);\u000a\u000a        switch(last) {\u000a        case 'y':\u000a\u000a            // rays, convoys\u000a            if (!isConsonant(s.charAt(s.length - 2))) {\u000a                return s + "s";\u000a            }\u000a            // harpies, cries\u000a            else {\u000a                return s.slice(0, s.length - 1) + "ies";\u000a            }\u000a            break;\u000a\u000a        // oxen, boxen, foxen\u000a        case 'x':\u000a            return s.slice(0, s.length - 1) + "en";\u000a        case 'z':\u000a            return s.slice(0, s.length - 1) + "es";\u000a        case 'h':\u000a            return s.slice(0, s.length - 1) + "es";\u000a\u000a        default:\u000a            return s + "s";\u000a        };\u000a\u000a    },\u000a\u000a    ed : function(s) {\u000a\u000a        var index = s.indexOf(" ");\u000a        var s = s;\u000a        var rest = "";\u000a        if (index > 0) {\u000a            rest = s.substring(index, s.length);\u000a            s = s.substring(0, index);\u000a\u000a        }\u000a\u000a        var last = s.charAt(s.length - 1);\u000a\u000a        switch(last) {\u000a        case 'y':\u000a\u000a            // rays, convoys\u000a            if (isConsonant(s.charAt(s.length - 2))) {\u000a                return s.slice(0, s.length - 1) + "ied" + rest;\u000a\u000a            }\u000a            // harpies, cries\u000a            else {\u000a                return s + "ed" + rest;\u000a            }\u000a            break;\u000a        case 'e':\u000a            return s + "d" + rest;\u000a\u000a            break;\u000a\u000a        default:\u000a            return s + "ed" + rest;\u000a        };\u000a    }\u000a};\u000a/**\u000a * @author Kate Compton\u000a */\u000a\u000a// A tracery expansion node\u000avar nodeCount = 0;\u000a\u000avar ExpansionNode = Class.extend({\u000a    init : function() {\u000a        this.depth = 0;\u000a        this.id = nodeCount;\u000a        nodeCount++;\u000a        this.childText = "[[UNEXPANDED]]";\u000a    },\u000a\u000a    setParent : function(parent) {\u000a        if (parent) {\u000a            this.depth = parent.depth + 1;\u000a            this.parent = parent;\u000a            this.grammar = parent.grammar;\u000a        }\u000a    },\u000a\u000a    expand : function() {\u000a        // do nothing\u000a        return "???";\u000a    },\u000a\u000a    expandChildren : function() {\u000a\u000a        if (this.children) {\u000a            this.childText = "";\u000a            for (var i = 0; i < this.children.length; i++) {\u000a                this.children[i].expand();\u000a                this.childText += this.children[i].finalText;\u000a            }\u000a            this.finalText = this.childText;\u000a        }\u000a\u000a    },\u000a\u000a    createChildrenFromSections : function(sections) {\u000a        var root = this;\u000a        this.children = sections.map(function(section) {\u000a\u000a            if ( typeof section == 'string' || section instanceof String) {\u000a                // Plaintext\u000a                return new TextNode(root, section);\u000a            } else {\u000a                return new TagNode(root, section);\u000a            }\u000a        });\u000a    }\u000a});\u000a\u000avar RootNode = ExpansionNode.extend({\u000a    init : function(grammar, rawRule) {\u000a        this._super();\u000a        this.grammar = grammar;\u000a        this.parsedRule = parseRule(rawRule);\u000a    },\u000a\u000a    expand : function() {\u000a        var root = this;\u000a        this.createChildrenFromSections(this.parsedRule);\u000a\u000a        // expand the children\u000a        this.expandChildren();\u000a    },\u000a});\u000a\u000avar TagNode = ExpansionNode.extend({\u000a    init : function(parent, parsedTag) {\u000a        this._super();\u000a\u000a        if (!(parsedTag !== null && typeof parsedTag === 'object')) {\u000a            if ( typeof parsedTag == 'string' || parsedTag instanceof String) {\u000a                console.warn("Can't make tagNode from unparsed string!");\u000a                parsedTag = parseTag(parsedTag);\u000a\u000a            } else {\u000a                console.log("Unknown tagNode input: ", parsedTag);\u000a                throw ("Can't make tagNode from strange tag!");\u000a\u000a            }\u000a        }\u000a\u000a        this.setParent(parent);\u000a        $.extend(this, parsedTag);\u000a    },\u000a\u000a    expand : function() {\u000a        if (tracery.outputExpansionTrace)\u000a            console.log(r.sections);\u000a\u000a        this.rule = this.grammar.getRule(this.symbol);\u000a\u000a        this.actions = [];\u000a\u000a        // Parse the rule if it hasn't been already\u000a        this.createChildrenFromSections(this.rule.getParsed());\u000a\u000a        // Do any pre-expansion actions!\u000a        for (var i = 0; i < this.preActions.length; i++) {\u000a            var action = new Action(this, this.preActions[i]);\u000a            action.activate();\u000a        }\u000a\u000a        // Map each child section to a node\u000a        if (!this.rule.sections)\u000a            console.log(this.rule);\u000a\u000a        this.expandChildren();\u000a\u000a        for (var i = 0; i < this.actions.length; i++) {\u000a\u000a            this.actions[i].deactivate();\u000a        }\u000a\u000a        this.finalText = this.childText;\u000a        for (var i = 0; i < this.mods.length; i++) {\u000a            this.finalText = this.grammar.applyMod(this.mods[i], this.finalText);\u000a        }\u000a\u000a    },\u000a\u000a    toLabel : function() {\u000a        return this.symbol;\u000a    },\u000a    toString : function() {\u000a        return "TagNode '" + this.symbol + "' mods:" + this.mods + ", preactions:" + this.preActions + ", postactions" + this.postActions;\u000a    }\u000a});\u000a\u000avar TextNode = ExpansionNode.extend({\u000a    isLeaf : true,\u000a    init : function(parent, text) {\u000a        this._super();\u000a\u000a        this.setParent(parent);\u000a\u000a        this.text = text;\u000a\u000a        this.finalText = text;\u000a    },\u000a    expand : function() {\u000a        // do nothing\u000a    },\u000a\u000a    toLabel : function() {\u000a        return this.text;\u000a    }\u000a});\u000a\u000a/**\u000a * @author Kate Compton\u000a */\u000a\u000afunction Symbol(grammar, key) {\u000a    this.grammar = grammar;\u000a    this.key = key;\u000a    this.currentRules = undefined;\u000a    this.ruleSets = [];\u000a\u000a};\u000a\u000aSymbol.prototype.loadFrom = function(rules) {\u000a\u000a    rules = this.wrapRules(rules);\u000a    this.baseRules = rules;\u000a\u000a    this.ruleSets.push(rules);\u000a    this.currentRules = this.ruleSets[this.ruleSets.length - 1];\u000a\u000a};\u000a\u000a//========================================================\u000a// Iterating over rules\u000a\u000aSymbol.prototype.mapRules = function(fxn) {\u000a\u000a    return this.currentRules.mapRules(fxn);\u000a};\u000a\u000aSymbol.prototype.applyToRules = function(fxn) {\u000a    this.currentRules.applyToRules(fxn);\u000a};\u000a\u000a//==================================================\u000a// Rule pushpops\u000aSymbol.prototype.wrapRules = function(rules) {\u000a    if (rules.prototype !== RuleSet) {\u000a        if (Array.isArray(rules)) {\u000a            return new RuleSet(rules);\u000a        } else if ( typeof rules == 'string' || rules instanceof String) {\u000a            return new RuleSet(rules);\u000a        } else {\u000a            throw ("Unknown rules type: " + rules);\u000a        }\u000a    }\u000a    // already a ruleset\u000a    return rules;\u000a};\u000a\u000aSymbol.prototype.pushRules = function(rules) {\u000a    rules = this.wrapRules(rules);\u000a    this.ruleSets.push(rules);\u000a    this.currentRules = this.ruleSets[this.ruleSets.length - 1];\u000a};\u000a\u000aSymbol.prototype.popRules = function() {\u000a    var exRules = this.ruleSets.pop();\u000a\u000a    if (this.ruleSets.length === 0) {\u000a        //console.warn("No more rules for " + this + "!");\u000a    }\u000a    this.currentRules = this.ruleSets[this.ruleSets.length - 1];\u000a};\u000a\u000a// Clear everything and set the rules\u000aSymbol.prototype.setRules = function(rules) {\u000a\u000a    rules = this.wrapRules(rules);\u000a    this.ruleSets = [rules];\u000a    this.currentRules = rules;\u000a\u000a};\u000a\u000aSymbol.prototype.addRule = function(rule) {\u000a    this.currentRules.addRule(seed);\u000a};\u000a\u000a//========================================================\u000a// selection\u000a\u000aSymbol.prototype.select = function() {\u000a    this.isSelected = true;\u000a\u000a};\u000a\u000aSymbol.prototype.deselect = function() {\u000a    this.isSelected = false;\u000a};\u000a\u000a//==================================================\u000a// Getters\u000a\u000aSymbol.prototype.getRule = function(seed) {\u000a    return this.currentRules.get(seed);\u000a};\u000a\u000a//==================================================\u000a\u000aSymbol.prototype.toString = function() {\u000a    return this.key + ": " + this.currentRules + "(overlaying " + (this.ruleSets.length - 1) + ")";\u000a};\u000aSymbol.prototype.toJSON = function() {\u000a\u000a    var rules = this.baseRules.rules.map(function(rule) {\u000a        return '"' + rule.raw + '"';\u000a    });\u000a    return '"' + this.key + '"' + ": [" + rules.join(", ") + "]";\u000a};\u000a\u000aSymbol.prototype.toHTML = function(useSpans) {\u000a    var keySpan = '"' + this.key + '"';\u000a    if (useSpans)\u000a        keySpan = "<span class='symbol symbol_" + this.key + "'>" + keySpan + "</span>";\u000a\u000a    var rules = this.baseRules.rules.map(function(rule) {\u000a        var s = '"' + rule.raw + '"';\u000a        if (useSpans)\u000a            s = "<span class='rule'>" + s + "</span>";\u000a        return s;\u000a    });\u000a    return keySpan + ": [" + rules.join(", ") + "]";\u000a};\u000a\u000a/**\u000a * @author Kate Compton\u000a */\u000a\u000afunction Grammar() {\u000a    this.clear();\u000a};\u000a\u000aGrammar.prototype.clear = function() {\u000a    // Symbol library\u000a    this.symbols = {};\u000a    \u000a    this.errors = [];\u000a    \u000a    // Modifier library\u000a    this.modifiers = {};\u000a\u000a    // add the universal mods\u000a    for (var mod in universalModifiers) {\u000a        if (universalModifiers.hasOwnProperty(mod))\u000a            this.modifiers[mod] = universalModifiers[mod];\u000a    }\u000a};\u000a//========================================================\u000a// Loading\u000a\u000aGrammar.prototype.loadFrom = function(obj) {\u000a    var symbolSrc;\u000a\u000a    this.clear();\u000a\u000a    if (obj.symbols !== undefined) {\u000a        symbolSrc = obj.symbols;\u000a    } else {\u000a        symbolSrc = obj;\u000a    }\u000a\u000a    // get all json keys\u000a    var keys = Object.keys(symbolSrc);\u000a\u000a    this.symbolNames = [];\u000a    for (var i = 0; i < keys.length; i++) {\u000a        var key = keys[i];\u000a        this.symbolNames.push(key);\u000a\u000a        this.symbols[key] = new Symbol(this, key);\u000a        this.symbols[key].loadFrom(symbolSrc[key]);\u000a    }\u000a\u000a};\u000a\u000aGrammar.prototype.toHTML = function(useSpans) {\u000a    // get all json keys\u000a    var keys = Object.keys(this.symbols);\u000a\u000a    this.symbolNames = [];\u000a\u000a    var lines = [];\u000a\u000a    var count = 0;\u000a    for (var i = 0; i < keys.length; i++) {\u000a\u000a        var key = keys[i];\u000a        var symbol = this.symbols[key];\u000a\u000a        if (symbol && symbol.baseRules) {\u000a\u000a            lines.push("    " + this.symbols[key].toHTML(useSpans));\u000a\u000a        }\u000a    };\u000a\u000a    var s;\u000a    s = lines.join(",</p><p>");\u000a    s = "{<p>" + s + "</p>}";\u000a    return s;\u000a};\u000a\u000aGrammar.prototype.toJSON = function() {\u000a    // get all json keys\u000a    var keys = Object.keys(this.symbols);\u000a\u000a    this.symbolNames = [];\u000a\u000a    var lines = [];\u000a\u000a    var count = 0;\u000a    for (var i = 0; i < keys.length; i++) {\u000a\u000a        var key = keys[i];\u000a        var symbol = this.symbols[key];\u000a\u000a        if (symbol && symbol.baseRules) {\u000a\u000a            lines.push("    " + this.symbols[key].toJSON());\u000a\u000a        }\u000a    };\u000a\u000a    var s;\u000a    s = lines.join(",\u005cn");\u000a    s = "{\u005cn" + s + "\u005cn}";\u000a    return s;\u000a};\u000a\u000a//========================================================\u000a// selection\u000a\u000aGrammar.prototype.select = function() {\u000a    this.isSelected = true;\u000a};\u000a\u000aGrammar.prototype.deselect = function() {\u000a    this.isSelected = false;\u000a};\u000a\u000a//========================================================\u000a// Iterating over symbols\u000a\u000aGrammar.prototype.mapSymbols = function(fxn) {\u000a    var symbols = this.symbols;\u000a    return this.symbolNames.map(function(name) {\u000a        return fxn(symbols[name], name);\u000a    });\u000a};\u000a\u000aGrammar.prototype.applyToSymbols = function(fxn) {\u000a    for (var i = 0; i < this.symbolNames.length; i++) {\u000a        var key = this.symbolNames[i];\u000a        fxn(this.symbols[key], key);\u000a    }\u000a};\u000a\u000a//========================================================\u000aGrammar.prototype.addOrGetSymbol = function(key) {\u000a    if (this.symbols[key] === undefined)\u000a        this.symbols[key] = new Symbol(key);\u000a\u000a    return this.symbols[key];\u000a};\u000a\u000aGrammar.prototype.pushRules = function(key, rules) {\u000a    var symbol = this.addOrGetSymbol(key);\u000a    symbol.pushRules(rules);\u000a};\u000a\u000aGrammar.prototype.popRules = function(key, rules) {\u000a    var symbol = this.addOrGetSymbol(key);\u000a    var popped = symbol.popRules();\u000a\u000a    if (symbol.ruleSets.length === 0) {\u000a        // remove symbol\u000a        this.symbols[key] = undefined;\u000a    }\u000a};\u000a\u000aGrammar.prototype.applyMod = function(modName, text) {\u000a    if (!this.modifiers[modName]) {\u000a        console.log(this.modifiers);\u000a        throw ("Unknown mod: " + modName);\u000a    }\u000a    return this.modifiers[modName](text);\u000a};\u000a\u000a//============================================================\u000aGrammar.prototype.getRule = function(key, seed) {\u000a    var symbol = this.symbols[key];\u000a    if (symbol === undefined) {\u000a        var r = new Rule("{{" + key + "}}");\u000a\u000a        r.error = "Missing symbol " + key;\u000a        return r;\u000a    }\u000a\u000a    var rule = symbol.getRule();\u000a    if (rule === undefined) {\u000a        var r = new Rule("[" + key + "]");\u000a        console.log(r.sections);\u000a        r.error = "Symbol " + key + " has no rule";\u000a        return r;\u000a    }\u000a\u000a    return rule;\u000a};\u000a\u000a//============================================================\u000a// Expansions\u000aGrammar.prototype.expand = function(raw) {\u000a\u000a    // Start a new tree\u000a    var root = new RootNode(this, raw);\u000a\u000a    root.expand();\u000a\u000a    return root;\u000a};\u000a\u000aGrammar.prototype.flatten = function(raw) {\u000a\u000a    // Start a new tree\u000a    var root = new RootNode(this, raw);\u000a\u000a    root.expand();\u000a\u000a    return root.childText;\u000a};\u000a\u000a//===============\u000a\u000aGrammar.prototype.analyze = function() {\u000a    this.symbolNames = [];\u000a    for (var name in this.symbols) {\u000a        if (this.symbols.hasOwnProperty(name)) {\u000a            this.symbolNames.push(name);\u000a        }\u000a    }\u000a\u000a    // parse every rule\u000a\u000a    for (var i = 0; i < this.symbolNames.length; i++) {\u000a        var key = this.symbolNames[i];\u000a        var symbol = this.symbols[key];\u000a        // parse all\u000a        for (var j = 0; j < symbol.baseRules.length; j++) {\u000a            var rule = symbol.baseRules[j];\u000a            rule.parsed = tracery.parse(rule.raw);\u000a            //   console.log(rule);\u000a\u000a        }\u000a    }\u000a\u000a};\u000a\u000aGrammar.prototype.selectSymbol = function(key) {\u000a    console.log(this);\u000a    var symbol = this.get(key);\u000a};\u000a/**\u000a * @author Kate Compton\u000a\u000a */\u000a\u000atracery.createGrammar = function(obj) {\u000a    var grammar = new Grammar();\u000a    grammar.loadFrom(obj);\u000a    return grammar;\u000a};\u000a\u000atracery.test = function() {\u000a\u000a    console.log("==========================================");\u000a    console.log("test tracery");\u000a\u000a    // good\u000a    tracery.testParse("", false);\u000a    tracery.testParse("fooo", false);\u000a    tracery.testParse("####", false);\u000a    tracery.testParse("#[]#[]##", false);\u000a    tracery.testParse("#someSymbol# and #someOtherSymbol#", false);\u000a    tracery.testParse("#someOtherSymbol.cap.pluralize#", false);\u000a    tracery.testParse("#[#do some things#]symbol.mod[someotherthings[and a function]]#", false);\u000a    tracery.testParse("#[fxn][fxn][fxn[subfxn]]symbol[[fxn]]#", false);\u000a    tracery.testParse("#[fxn][#fxn#][fxn[#subfxn#]]symbol[[fxn]]#", false);\u000a    tracery.testParse("#hero# ate some #color# #animal.s#", false);\u000a    tracery.testParseTag("[action]symbol.mod1.mod2[postAction]", false);\u000a\u000a    // bad\u000a    tracery.testParse("#someSymbol# and #someOtherSymbol", true);\u000a    tracery.testParse("#[fxn][fxn][fxn[subfxn]]symbol[fxn]]#", true);\u000a\u000a    // bad\u000a    tracery.testParseTag("stuff[action]symbol.mod1.mod2[postAction]", true);\u000a    tracery.testParseTag("[action]symbol.mod1.mod2[postAction]stuff", true);\u000a\u000a    tracery.testParse("#hero# ate some #color# #animal.s#", true);\u000a    tracery.testParse("#[#setPronouns#][#setOccupation#][hero:#name#]story#", true);\u000a\u000a};\u000a \u000a})();
p42
sg23
Vtracery.js (no require)
p43
sg25
g26
((I2015
I5
I29
I12
I0
I45
I4
I149
I1
tp44
(dp45
tp46
Rp47
sg31
(lp48
Vscript
p49
asg33
g26
((I2015
I5
I29
I11
I56
I58
I4
I149
I1
tp50
(dp51
tp52
Rp53
sbsa(dp54
g14
I00
sg15
(lp55
F10.0
aF570.0
asg17
(itiddlywiki
Tiddler
p56
(dp57
g21
V/%\u000a\u000aUses the parameter if one was passed. Then, checks for the $symbol variable. If neither is present, uses "origin". Clears $symbol at the end.\u000a\u000a%/<<if parameter(0)>><<set $symbol to parameter(0)>><<else>><<if $symbol>><<else>><<set $symbol to "origin">><<endif>><<endif>><<print console.log("trace " + $symbol)>><<print tale.grammar.flatten("#" + $symbol + "#")>><<forget $symbol>>
p58
sg23
Vtrace
p59
sg25
g26
((I2015
I5
I30
I14
I4
I9
I5
I150
I1
tp60
(dp61
tp62
Rp63
sg31
(lp64
sg33
g26
((I2015
I5
I29
I12
I1
I13
I4
I149
I1
tp65
(dp66
tp67
Rp68
sbsa(dp69
g14
I00
sg15
(lp70
F10.0
aF10.0
asg17
(itiddlywiki
Tiddler
p71
(dp72
g21
Vv.2016-08-25
p73
sg23
Vtwinecery version
p74
sg25
g26
((I2016
I8
I26
I0
I39
I21
I4
I239
I1
tp75
(dp76
tp77
Rp78
sg31
(lp79
Vannotation
p80
asg33
g26
((I2015
I5
I29
I22
I0
I26
I4
I149
I1
tp81
(dp82
tp83
Rp84
sbsa(dp85
g14
I00
sg15
(lp86
F290.0
aF10.0
asg17
(itiddlywiki
Tiddler
p87
(dp88
g21
Vtwinecery checks for Twine passages tagged "grammar", then splits them based on newlines and turns them into a Tracery object. Run traces with <<trace>> or <<trace "someSymbol">>. You can also link to a trace as a passage by itself with [[trace]] or [[trace][$symbol = "someSymbol"]]. If no symbol is specified, it defaults to "origin".
p89
sg23
Vtwinecery readme
p90
sg25
g26
((I2015
I5
I30
I12
I46
I22
I5
I150
I1
tp91
(dp92
tp93
Rp94
sg31
(lp95
Vannotation
p96
asg33
g26
((I2015
I5
I30
I12
I43
I4
I5
I150
I1
tp97
(dp98
tp99
Rp100
sbsa(dp101
g14
I00
sg15
(lp102
F150.0
aF570.0
asg17
(itiddlywiki
Tiddler
p103
(dp104
g21
V// Expands a symbol and returns the output.\u000awindow.trace = function(symbol){\u000a	if(symbol === undefined){\u000a		symbol = "origin";\u000a	}\u000a	if(tale.grammar === undefined){\u000a		console.log("Couldn't find the grammar object.");\u000a		return "ERROR: Grammar object not found.";\u000a	}\u000a\u000a	var output = tale.grammar.flatten("#" + symbol + "#")	\u000a//	console.log(symbol + " expands to:\u005cn" + output);\u000a	return output;\u000a}
p105
sg23
Vwindow.trace
p106
sg25
g26
((I2016
I9
I5
I14
I19
I55
I0
I249
I1
tp107
(dp108
tp109
Rp110
sg31
(lp111
Vscript
p112
asg33
g26
((I2015
I8
I23
I1
I40
I36
I6
I235
I1
tp113
(dp114
tp115
Rp116
sbsa(dp117
g14
I00
sg15
(lp118
F10.0
aF850.0
asg17
(itiddlywiki
Tiddler
p119
(dp120
g21
V// This is a slightly modified version of Leon Arnott's cyclinglink macro.\u000a\u000aversion.extensions.tracelinkMacro = {\u000a	major: 0,\u000a	minor: 1,\u000a	revision: 0\u000a};\u000amacros.tracelink = {\u000a	handler: function(a, b, c) {\u000a		var rl = "traceLink";\u000a\u000a		function toggleText(w) {\u000a			w.classList.remove("traceLinkInit");\u000a			w.classList.toggle(rl + "Enabled");\u000a			w.classList.toggle(rl + "Disabled");\u000a			w.style.display = ((w.style.display == "none") ? "inline" : "none")\u000a		}\u000a		switch (c[c.length - 1]) {\u000a			case "end":\u000a				var end = true;\u000a				c.pop();\u000a				break;\u000a			case "out":\u000a				var out = true;\u000a				c.pop();\u000a				break\u000a		}\u000a		var v = "";\u000a		if (c.length && c[0][0] == "$") {\u000a			v = c[0].slice(1);\u000a			c.shift()\u000a		}\u000a		var h = state.history[0].variables;\u000a		if (out && h[v] === "") {\u000a			return\u000a		}\u000a		var l = Wikifier.createInternalLink(a, null);\u000a		l.className = "internalLink cyclingLink";\u000a		l.setAttribute("data-cycle", 0);\u000a\u000a		// Prebake a bunch of traces and use those as our links to cycle through.\u000a		c = traceArray(c[0], 64);\u000a\u000a		for (var i = 0; i < c.length; i++) {\u000a			var on = (i == Math.max(c.indexOf(h[v]), 0));\u000a			var d = insertElement(null, "span", null, "traceLinkInit traceLink" + ((on) ? "En" : "Dis") + "abled");\u000a			if (on) {\u000a				h[v] = c[i];\u000a				l.setAttribute("data-cycle", i)\u000a			} else {\u000a				d.style.display = "none"\u000a			}\u000a			insertText(d, c[i]);\u000a			if (on && end && i == c.length - 1) {\u000a				l.parentNode.replaceChild(d, l)\u000a			} else {\u000a				l.appendChild(d)\u000a			}\u000a		}\u000a		l.onclick = function() {\u000a			var t = this.childNodes;\u000a			var u = this.getAttribute("data-cycle") - 0;\u000a			var m = t.length;\u000a			toggleText(t[u]);\u000a			u = (u + 1);\u000a			if (!(out && u == m)) {\u000a				u %= m;\u000a				if (v) {\u000a					h[v] = c[u]\u000a				}\u000a			} else {\u000a				h[v] = ""\u000a			}\u000a			if ((end || out) && u == m - (end ? 1 : 0)) {\u000a				if (end) {\u000a					var n = this.removeChild(t[u]);\u000a					n.className = rl + "End";\u000a					n.style.display = "inline";\u000a					this.parentNode.replaceChild(n, this)\u000a				} else {\u000a					this.parentNode.removeChild(this);\u000a					return\u000a				}\u000a				return\u000a			}\u000a			toggleText(t[u]);\u000a			this.setAttribute("data-cycle", u)\u000a		}\u000a	}\u000a};
p121
sg23
Vtracelink
p122
sg25
g26
((I2015
I11
I30
I23
I34
I3
I0
I334
I0
tp123
(dp124
tp125
Rp126
sg31
(lp127
Vscript
p128
asg33
g26
((I2015
I11
I23
I21
I57
I14
I0
I327
I0
tp129
(dp130
tp131
Rp132
sbsa(dp133
g14
I00
sg15
(lp134
F150.0
aF850.0
asg17
(itiddlywiki
Tiddler
p135
(dp136
g21
V@keyframes cyc-shudder-in {\u000a   0%, 100% { transform: translateX(0em); }\u000a   5%, 25%, 45% { transform: translateX(-1em); }\u000a   15%, 35%, 55% { transform: translateX(1em); }\u000a   65% { transform: translateX(-0.6em); }\u000a   75% { transform: translateX(0.6em); }\u000a   85% { transform: translateX(-0.2em); }\u000a   95% { transform: translateX(0.2em); }\u000a}\u000a@-webkit-keyframes cyc-shudder-in {\u000a   0%, 100% { -webkit-transform: translateX(0em); }\u000a   5%, 25%, 45% { -webkit-transform: translateX(-1em); }\u000a   15%, 35%, 55% { -webkit-transform: translateX(1em); }\u000a   65% { -webkit-transform: translateX(-0.6em); }\u000a   75% { -webkit-transform: translateX(0.6em); }\u000a   85% { -webkit-transform: translateX(-0.2em); }\u000a   95% { -webkit-transform: translateX(0.2em); }\u000a}\u000a.traceLinkEnabled {\u000a  color: rgb(255, 0, 255);\u000a  display: inline-block !important;\u000a  animation: cyc-shudder-in 0.4s; -webkit-animation: cyc-shudder-in 0.4s;\u000a}\u000a.traceLinkInit, .traceLinkInit::before {\u000a  color: rgb(255, 0, 255);\u000a  animation-iteration-count: 0 !important;\u000a  -webkit-animation-iteration-count: 0 !important;\u000a}
p137
sg23
Vtracelink shudder effect
p138
sg25
g26
((I2016
I9
I5
I14
I19
I11
I0
I249
I1
tp139
(dp140
tp141
Rp142
sg31
(lp143
Vstylesheet
p144
asg33
g26
((I2015
I11
I24
I2
I32
I35
I1
I328
I0
tp145
(dp146
tp147
Rp148
sbsa(dp149
g14
I00
sg15
(lp150
F430.0
aF570.0
asg17
(itiddlywiki
Tiddler
p151
(dp152
g21
VString.prototype.contains = function(substring){\u000a	if (substring.constructor === Array){\u000a		for (var i = 0; i < substring.length; i++){\u000a			if(this.contains(substring[i])){\u000a				return substring[i]; // Non-empty string evaluates to true\u000a			}\u000a		}\u000a		return false;\u000a	} else {\u000a		return this.indexOf(substring) > 0;\u000a	}\u000a}
p153
sg23
VString.contains
p154
sg25
g26
((I2015
I12
I1
I1
I49
I24
I1
I335
I0
tp155
(dp156
tp157
Rp158
sg31
(lp159
Vscript
p160
asg33
g26
((I2015
I11
I30
I22
I48
I46
I0
I334
I0
tp161
(dp162
tp163
Rp164
sbsa(dp165
g14
I00
sg15
(lp166
F430.0
aF290.0
asg17
(itiddlywiki
Tiddler
p167
(dp168
g21
Vwindow.grammar = function(rule){\u000a	return tale.get(rule).text.split('\u005cn');\u000a}
p169
sg23
Vwindow.grammar
p170
sg25
g26
((I2016
I5
I4
I1
I33
I51
I2
I125
I1
tp171
(dp172
tp173
Rp174
sg31
(lp175
Vscript
p176
asg33
g26
((I2015
I11
I30
I23
I25
I52
I0
I334
I0
tp177
(dp178
tp179
Rp180
sbsa(dp181
g14
I00
sg15
(lp182
F570.0
aF570.0
asg17
(itiddlywiki
Tiddler
p183
(dp184
g21
V// Returns a new version of a given expansion.\u000awindow.retrace = function(symbol, old, maxAttempts){\u000a	if(maxAttempts === undefined){\u000a		maxAttempts = 32;\u000a	}\u000a	if(!(maxAttempts > 1)){\u000a		maxAttempts = 1;\u000a	}\u000a	\u000a	var output = "", attempts = 0;\u000a	do{\u000a		output = trace(symbol);\u000a		attempts++;\u000a	}while(output == old && attempts < maxAttempts)\u000a\u000a//	console.log("retrace:"\u000a//				+ "\u005cn\u005ctold: " + old\u000a//				+ "\u005cn\u005ctnew: " + output\u000a//				+ "\u005cn\u005ctattempts: " + attempts)\u000a	return output;\u000a}
p185
sg23
Vwindow.retrace
p186
sg25
g26
((I2016
I8
I26
I0
I46
I58
I4
I239
I1
tp187
(dp188
tp189
Rp190
sg31
(lp191
Vscript
p192
asg33
g26
((I2015
I11
I30
I23
I30
I18
I0
I334
I0
tp193
(dp194
tp195
Rp196
sbsa(dp197
g14
I00
sg15
(lp198
F290.0
aF570.0
asg17
(itiddlywiki
Tiddler
p199
(dp200
g21
V// Returns an array of traces, each different from the one preceding it unless retrace() maxes out attempts.\u000a\u000awindow.traceArray = function(symbol, num){\u000a	var output = [];\u000a	output.push( trace(symbol) );\u000a\u000a	for (var i = 1; i < num; i++) {\u000a		output.push( retrace(symbol, output[i-1]) );\u000a	};\u000a\u000a	return output;\u000a}
p201
sg23
Vwindow.traceArray
p202
sg25
g26
((I2016
I8
I26
I0
I47
I12
I4
I239
I1
tp203
(dp204
tp205
Rp206
sg31
(lp207
Vscript
p208
asg33
g26
((I2015
I11
I30
I23
I30
I38
I0
I334
I0
tp209
(dp210
tp211
Rp212
sbsa(dp213
g14
I00
sg15
(lp214
F290.0
aF290.0
asg17
(itiddlywiki
Tiddler
p215
(dp216
g21
V//requires jquery\u000a\u000aStory.prototype.appendJSON = function() {\u000a	var JSONtoAppend = tale.lookup("tags", "JSON");\u000a	if(!JSONtoAppend.length) return;\u000a\u000a	for(i in JSONtoAppend){\u000a		var newJSON = JSON.parse(JSONtoAppend[i].text);\u000a		$.extend(this.data, newJSON);\u000a	}\u000a	console.log("appended");\u000a}\u000a\u000afunction Story(){\u000a	var grammars = tale.lookup("tags", "grammar", "title");\u000a	this.data = {};\u000a\u000a	var links = /(\u005c[\u005c[\u005cb)(.+?)(\u005cb\u005c]\u005c])/g;\u000a	var sublinks = /([^\u005c[\u005c]]+)*(.+)/\u000a\u000a	function convertSyntax(match, p1, p2, p3){\u000a		// If a passage is invoked that's tagged as a grammar, change Twine links into Tracery symbols.\u000a		// e.g.: [[animal]] => #animal#\u000a		// e.g.: [[animal][capitalize]] => #animal.capitalize#\u000a\u000a		// p1 is left brackets, p3 is right brackets\u000a		var targetLink = p2.split("][")[0];\u000a		var modifiers = p2.split("][").slice(1, p2.length).join(".");\u000a		modifiers = modifiers?("." + modifiers):"";\u000a		\u000a		var trace = "#" + targetLink + modifiers + "#";\u000a		\u000a		var linkIsGrammar = false;\u000a		var tags = tale.get(targetLink).tags\u000a		for(var i = 0; i < tags.length; i++){\u000a			if(tags[i] == "grammar"){\u000a				linkIsGrammar = true;\u000a				break;\u000a			}\u000a		}\u000a\u000a		return linkIsGrammar?trace:match;\u000a	}\u000a\u000a	for(var i in grammars){\u000a		if(grammars[i] == undefined) continue;\u000a\u000a		// Passage names become grammar names, Passage text becomes grammar text. \u000a		var newSymbol = grammars[i].title\u000a		var newText = grammars[i].text\u000a\u000a		var link = /(\u005c[\u005c[\u005cb)(.+?)(\u005cb\u005c]\u005c])/g;\u000a		newText = newText.replace(link, convertSyntax);\u000a		// Get everything that's being linked to.\u000a\u000a		this.data[newSymbol] = newText.split('\u005cn');\u000a	}\u000a\u000a	this.appendJSON();\u000a	console.log("Story: ", this);\u000a}\u000aStory.prototype.constructor = Story;\u000a\u000a// Append this to the tale object because I don't know where else to put it.\u000aTale.prototype.story = new Story();\u000a\u000aStory.prototype.toHTML = function() {\u000a	var output = [];\u000a	var tab = "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;";\u000a	var beg = '\u005cn' + tab + "\u005c"<span class=\u005c"grammarContents\u005c">{{{"\u000a	var end = "}}}</span>\u005c""\u000a\u000a	for(var i in this.data){\u000a		var gram = "<span class=\u005c"grammarTitle\u005c">\u005c"" + i + "\u005c"</span>: [";\u000a		gram += beg + this.data[i].join(end + ',' + beg) + end;\u000a		gram += "]";\u000a		output.push(gram);\u000a	}\u000a	return "{\u005cn" + output.join(",\u005cn") + "\u005cn}";\u000a}\u000a\u000aTale.prototype.JSONtoTwee = function() {\u000a	var JSONtoConvert = tale.lookup("tags", "JSON");\u000a	var combinedJSON = ""\u000a\u000a	for (var i in JSONtoConvert){\u000a		combinedJSON += JSONtoConvert[i].text;\u000a	}\u000a\u000a	// Note the {{{}}} delimiters in textPost. This is intended for display in Twine, so\u000a	// if you're just running these raw they aren't necessary.\u000a	var regex = {titlesPre: /\u005ct"(.+)": \u005c[/g, titlesPost: "<br>::  $1 [grammar]",\u000a				 textPre: /\u005ct*"(.+)",*(?:\u005cn\u005ct)?(?:\u005c],)*\u005cn/g, textPost: "{{{$1}}}<br>"}\u000a\u000a	var tweeOutput = combinedJSON.replace(regex.titlesPre, regex.titlesPost);\u000a	tweeOutput = tweeOutput.replace(regex.textPre, regex.textPost);\u000a	tweeOutput = tweeOutput.replace(/({\u005cn)|(]\u005cn})/g, "")\u000a\u000a	return tweeOutput;\u000a}
p217
sg23
VStory
p218
sg25
g26
((I2016
I8
I25
I22
I54
I26
I3
I238
I1
tp219
(dp220
tp221
Rp222
sg31
(lp223
Vscript
p224
asg33
g26
((I2016
I8
I25
I22
I54
I10
I3
I238
I1
tp225
(dp226
tp227
Rp228
sbsasS'scale'
p229
F0.8
sS'snapping'
p230
I01
ss.